---
typora-copy-images-to: ..\..\..\img
---

在并发编程里面，我们往往需要锁来实现数据的一致性，但使用锁有可能使得系统死锁来导致系统功能不可用。

避免死锁的办法：

1. 一个线程里面避免获取多个锁
2. 避免一个线程在锁内占用多个资源，尽量保证每个锁只占用一个资源。
3. 尝试使用定时锁，使用lock的tryLock(timeout)来替代使用内部锁机制。
4. 对于数据库锁，加锁和解锁必须在同一个数据库连接里面，负责会出现解锁失效的情况。



我们看一下ObjectMonitor.hpp的源码：

![1567132414245](..\..\..\img\1567132414245.png)

这个ObjectMonitor的作用就相当于锁的作用。
在ObjcetMonitor.cpp源码中，我们发现wait的源码如下：

![1567132369683](..\..\..\img\1567132369683.png)

我们发现其实是需要先把线程加入到等待队列，然后再释放锁。
那么，我们是不是可以这样说，一个线程只有获取到锁以后才能加入等待队列，所以wait执行的时候要先获取到锁？
 ———————————————— 
版权声明：本文为CSDN博主「让兔子飞」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/barlay/article/details/84890170


# <center>设计模式定义</center>

1. 创建型设计模式：为你创建对象，而不用你直接实例化对象。针对给定的案例，程序可以在确定需要创建哪些对象时获得更大的灵活性。
   - 工厂方法模式：提供一个简单的决策类，根据所提供的数据，它将返回一个抽象基类的若干可能子类的一个。
   - 抽象工厂模式：提供一个接口来创建和返回对各相关对象系列中的一个系列。
   - 构造器模式：把一个复杂对象的创建和其表示相分离，以便根据程序的需要创建多种不同的表示。
   - 原型模式：从一个实例化的类开始，通过复制或复制的方法创建新的实例。这些实例可进一步通过自己的公共方法进行裁剪，
   - 单例模式：程序最多只有一个实例的类。他提供了存取实例的一个全局入口。

2. 结构性模型：有助于将对象组合成更大的结构，例如复杂的用户界面和统计数据。类模式(class pattern)和对象模式(object pattern)的区别在于，

   - 类模式描述了如何用继承来提供更有用的程序接口。

   - 对象模式则描述了如何使用对象组合或者在其他对象中包含对象的方法，将对象组合成更大的结构。

     分类：

     1. 适配器(Adapter)模式：用于使一个类的接口与另一个类的接口匹配，从而方便功能。
     2. 组合(Composite)模式: 创建一个对象或对象的组合，其中每一个对象都是一个简单对象或组合对象。
     3. 代理(Proxy)模式:创建一个简单的对象，用来替代一个以后将被掉哟的更复杂的对象。
     4. 享元(Flyweight)模式：为了共享对象，其中每个实例未包含自己的状态，而是将状态在外部保存。当存在多个实例，但其类型仅稍有不同时，此方法可以高效地共享对象从而节省空间。
     5. 外观(Facade)模式：用单个类表示一个完整的子系统。
     6. 桥接(Bridge)模式： 把一个对象的接口与实现相分离，从而单独的进行修饰。
     7. 装饰器(Decorator)模式：为对象动态的增加职能。

3. 行为型模式“有助于定义系统中对象之间的通信，以及在一个复杂的程序中如何控制流程。

   - 职责链(Chain of Responsibility)模式:通过链的方式将请求从一个对象传递给下一个对象，直到请求得到识别，这样做可以解除对象之间的联系
   - 命令(Command)模式：利用简单的对象以软件命令的执行，并能支持日志记录和撤销模式。
   - 解释器模式(Interpreter):定义如何在程序中包含元素
   - 迭代器(Iterator)模式：将遍历数据列表的行为规范到一个类中。
   - 中介者(Mediator)模式：通过使用分离的对象来防止所有的对象批次互知，可简化对象之间的互相通信。
   - 观察者(Observer)模式：当发生改变时，该模式能确定如何通知多个对象。
   - 状态(State)模式：当内部状态发生改变时，允许对象改变它的 行为。
   - 策略(Strategy)模式：将算法封装到一个类中。
   - 模板方法(Template Method)模式:为算法提供一种抽象的定义。
   - 访问者(Visitor)模式:以友好的方式为类增加多态功能。



[旭日0东升：该博主总结了所有常见的设计模式](https://me.csdn.net/qq_15996553)

[JAVA UML](https://blog.csdn.net/sko121/article/details/52993150/)
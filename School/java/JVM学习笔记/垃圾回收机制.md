---
typora-copy-images-to: ..\..\..\img
---

# <center>垃圾收集机制</center>

&emsp;&emsp;java与C++之间有一堵由内存动态分配和垃圾回收技术所围成的“高墙”,墙外面的人想进去，墙里面的人想出来。

## 垃圾收集(Garbage Collection)

GC技术主要考虑三个问题：

1. 哪些内存需要回收
2. 什么时候进行回收
3. 如何回收

&emsp;&emsp;java内存区域中，程序计数器、虚拟机栈、本地方法栈是随着线程而生，随着线程而灭；栈中的栈帧随着方法的进入和退出有条不紊的执行入栈和出栈操作。而每一个<font color='red'>栈帧(用于存储局部变量表、操作数栈、动态链接、方法出口等信息)</font>分配多少内存基本上是在类结构确定下来时就已知的。因此这几个区域的内存分配和回收基本上具备了确定性，不需要考虑内存的回收问题，因为方法或者线程结束后，内存也随着回收了。但是java堆和方法区则不一样。一个接口的多个实现类需要的内存不一样，一个方法中的多个分支需要的内存也不一样，我们只有在程序运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的。垃圾回收器所关注的，也就是这部分内存。

### 如何判断哪些内存该回收了？

&emsp;&emsp;换句话说，怎么才能知道哪些内存已死，哪些内存还活着。

&emsp;&emsp;两种判断算法：引用计数算法法和可达性分析算法。

#### 引用计数算法

&emsp;&emsp;该算法给每一个对象添加一个引用计数器，每当有一个地方引用它时，计数器+1;当一个地方的引用失效时，计数器-1；任何时候当一个对象的被引用量为0时，说明这个对象不可用了，判定死亡。

&emsp;&emsp;改算法比较简单，效率也比较高，但是存在一个缺陷，导致许多主流的JAVA虚拟机都没有采用这个算法，这个缺陷就算循环引用的问题。举个例子：

```java
public class ReferenceCountTest{
    public static final int_1MB=1024*1024；
    private byte[] array=new byte[2*int_1MB];
    
    public Object instance=null;
    
    public static void testGC(){
		ReferenceCountTest objA=new ReferenceCountTest();
        ReferenceCountTest objB=new ReferenceCountTest();
        objA.instance=objB;
        objB.instance=objA;
        objA=null;
        objB=null;
        System.GC();
    }
}
```

&emsp;&emsp;在这种情况下，如果使用引用计数法，当objA和ojbB置为null后，此时两个对象被引用量为1，使用System.GC()函数后，内存不会被回收，因为对象的引用计数不为0。但实际操作中发现这两个对象仍然会被回收，因此我们通常用的java虚拟机都没有使用这个算法。

#### 可达性分析算法

&emsp;&emsp;主流的java虚拟机都是使用这个可达性分析(Reachability Analysis)来判断对象是否存活的。这个算法的思路就是通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索搜索所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连的时候，则这个对象是不可达的。

![1542011917423](..\..\..\img\1542011917423.png)

&emsp;&emsp;上图中，对象object5,6,7虽然有关联，但是并不在引用链上，也就是说到GC ROOTS是不可达的，因此他们会被判定为可回收的对象。

在java中，可以作为GC ROOTS的对象包括下面几种：

- 虚拟机栈(栈帧中的本地变量表)中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI(即一般所说的Native方法)引用的对象。

#### 再谈引用

- 强引用：强引用在代码中普遍存在，类似“Object A=new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收被引用的对象。
- 软引用：用来描述一些还有用但非必须的对象。在系统发生内存溢出之前，会对这些内存进行回收，如果回收后内存仍然不够用，就会抛出内存溢出异常。
- 弱引用：生存期只维持到下次GC之前。
- 虚引用：一个对象是否有虚引用的对象，完全不会对对象的生存时间产生影响。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

#### 方法区的回收

&emsp;&emsp;在方法区(永久代)的垃圾回收性价比比较低。永久代的垃圾回收主要回收两部分的内容：

- 废弃常量
- 无用的类

&emsp;&emsp;回收废弃常量比较简单。例如常量池中有个“ABC”的字符串，而此时系统的没有一个String对象是**叫做**“abc”的，换句话说，也就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量。

&emsp;&emsp;而判断一个无用的类的条件就比较苛刻。类需要同时满足以下三个条件才能被判定为无用的类：

1. 该类的所有实例都已经被回收，也就是java堆中不存在该类的任何实例。
2. 加载该类的ClassLoader已经被回收。
3. 该类对应的java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 垃圾收集算法

#### 垃圾清除(Mark-Sweep)算法

&emsp;&emsp;该算法分为标记-清除两个阶段，这种算法是最基础的算法，存在两个缺陷：

- 效率低：标记和清除的效率都低
- 产生大量的碎片，导致后面要为一个大对象分配内存时没有足够的连续内存，从而导致提前触发垃圾回收动作。

![1542018218858](..\..\..\img\1542018218858.png)

#### 复制算法

&emsp;&emsp;为了解决效率问题，提出了复制算法：它将内存分为两部分，每次都只是用其中一部分，但这一部分的内存使用完后，就将存活对象复制到另一块内存中去，然后再把已使用过的内存空间一次性清理掉。这样，每次都对整个半区进行清理，不存在碎片化问题。内存分配时也只需要移动堆顶指针。

但这种算法的代价是缩小了一般的内存。

![1542019060848](..\..\..\img\1542019060848.png)

&emsp;&emsp;而现在的商业虚拟机都采用复制算法来回收新生代，但并不是按照1：1的比例来划分内存的，而是将内存分为一快较大的Eden空间和两个较小的空间Survivor空间，每次只使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor存活的对象复制到另一块Survivor上面来，然后再一次性清理到Eden和刚才用过的Survivor空间。Hotpot虚拟机默认将Eden和Survivor空间大小设置为8：1。因此系统的可使用内存空间时90%。

&emsp;&emsp;但是，如果垃圾回收的时候发现，生存对象占用的内存超过10%。此时，需要其他内存(这里指老生代)进行分配担保。

#### 标记-整理算法

&emsp;&emsp;复制算法在对象存活率高的时候需要过多的复制操作，效率会变低。所以在老年代中不使用这种算法。这种算法与标记-清除算法的区别是，它不是直接对可回收对象进行清理，而是将所有存活的对象往一边移动懂，然后清理掉端边界以外的内存。

![1542020577683](..\..\..\img\1542020577683.png)

#### 分代收集算法

&emsp;&emsp;当前的虚拟机都使用分代收集算法，这种算法是根据对象存活周期将对象分为新生代和老生代。这样就可以对各个年代的区域使用最合适的算法。

&emsp;&emsp;在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，因此采用复制算法。而老年代的对象存活率高，没有额外的空间对他进行分配担保，因此使用标记清理或者标记整理的算法。

### HotSpot的算法实现

#### 枚举根节点+安全点

&emsp;&emsp;整个程序很大，在垃圾回收过程中，不可能一个不漏的检查完所有执行上下文和全局的引用位置，虚拟机得想个办法得知哪些地方存放着对象引用。在HotSpot中，使用了一组称为Oop得数据结构来达到这个目的，在类加载完成得时候，HotSpot就把对象内什么偏移量上什么类型的数据计算出来，在JIT编译过程中，也会在**特定的位置**记录下栈和寄存器中哪些位置是引用。这样GC在扫描的时候就直接得知这些信息了。而这些特定的位置，我们把它称为==安全点==，也就是说，并不是程序运行到在任何地方都能触发GC，只有到达安全点的时候才能暂停。而选定安全点的标准是以程序“是否具有让程序长时间执行的特性”，比如循环跳转、方法调用、异常跳转这些指令才会产生安全点。

&emsp;&emsp;而怎么让所有的线程跑到安全点再中断呢?两种方法：

1. 抢先式中断：GC发生时，中断所有的线程，如果线程中断的地方不在安全点上，恢复线程，让他跑到安全点再中断。
2. 主动式中断：在安全点上设置一个中断标志，每当线程运行到这个安全点时就轮询这个标志，发现为中断标志时，就中断线程。

#### 安全区域(safe region)

&emsp;&emsp;如果在某个区域中，引用的关系稳定不变的，在这个区域内任何一点进行GC都是安全的，这种区域是安全的，例如线程在Sleep状态或者Blocked状态。

&emsp;&emsp;因此，在线程执行到安全区域中的代码时，标识自己进入了安全区域。这样在GC的时候就不用非要执行到安全点；在离开安全区域的时候，要检查系统是否已经完成了根节点枚举，如果没完成，则要等待完成后再离开这个区域。

### 垃圾收集器

&emsp;&emsp;这里讨论的收集器基于JDK1.7 Update14之后的HotSpot虚拟机

![1542076880635](..\..\..\img\1542076880635.png)

&emsp;&emsp;上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明这两个收集器能搭配使用。

#### Serial/SerialOld收集器

&emsp;&emsp;顾名思义，“单线程收集器”表明了这款垃圾收集器只使用一条线程来进行垃圾回收，同时，在该线程运行的时候，要暂停系统的所有线程，直到它收集完成。

![1542083384828](..\..\..\img\1542083384828.png)

&emsp;&emsp;在进行垃圾回收的时候对程序的其他线程进行暂停的目的是==防止在垃圾收集线程运行的时候，系统的引用还在发生变化。但暂停其他线程的代价较大，因此，HotSpot团队一直在致力于减少因为垃圾回收而导致的任务暂停时间。

&emsp;&emsp;但并不是说Serial收集器就一无是处，它的简单高效性，使得在单个CPU的运行环境下没有线程交互的开销，专心的做垃圾回收工作自然可以获得最好的单线程收集效率。所以，在内存需求不大的应用，垃圾回收停顿时间可以控制在毫秒单位内。所以，Serial收集器运行在Client模式下的虚拟机来说是一个很好的选择。

#### ParNew收集器

&emsp;&emsp;ParNew收集器实际就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其他行为包括Serial收集器可用的所以控制参数(例如：-XX:SurvivorRatio(Eden和Survivor的内存比例)，-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等)、收集算法、Stop The World、对象分配规则、回收策略等都和Serial一样。

![1542083761688](..\..\..\img\1542083761688.png)

&emsp;&emsp;但是在单CPU运行环境下，ParNew的运行效率绝不会比Serial高，因为存在线程切换的开销。

#### Parallel Scavenge收集器(并行清理)

&emsp;&emsp;这款收集器也是一个新生代收集器，使用的是复制算法，也是多线程机制。但是它和其他收集器不同,CMS等收集器的关注点在于==尽可能的缩短垃圾收集时用户线程的停顿时间==，而Parallel Scavenge的关注点是达到一个可控制的==吞吐量==。

$吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)$

&emsp;&emsp;Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的**-XX:MaxGCPauseMillis**参数以及直接设置吞吐量大小的**-XX:GCTimeRadio**。

- **-XX:MaxGCPauseMillis**参数规定了内存回收所花费的时间上限，但是并不是把这个值设置的越小越好，因为缩小回收时间(停顿时间)的代价是牺牲了吞吐量和新生代空间的。例如：回收300MB新生代比500MB肯定要快，但是会增加垃圾回收的频率。
- **-XX:GCTimeRatio**参数是0-100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数；如果设置为19，则允许的最大GC时间为总时间的1/(1+19)=5%。

&emsp;&emsp;还有一个自动开关参数：**-XX:+UseAdaptiveSizePolicy**,当这个参数打开后，就不需要手工指定新生代的大小(-Xmn)，Eden和Survivor的比例(-XX:SurvivorRatio)、晋升老年代对象年龄(-XX:PretenureSizeThreshold)等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数从而获得最合适的停顿时间或者最大的吞吐量，这种方式叫做**GC的自适应调节策略。**

#### Parallel Old收集器

&emsp;&emsp;Parallel Old是Paraller Scavenge的老年代版本。使用多线程和标记-整理的方法。

&emsp;&emsp;在注重吞吐量和CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old收集器。

![1542085840721](..\..\..\img\1542085840721.png)

#### CMS(Concurrent Mark Sweep) 收集器

&emsp;&emsp;这款收集器可以说是一个划时代的收集器，它是HotSpot虚拟机种第一款真正意义上的并发收集器，第一次实现了让垃圾收集线程和用户线程==基本上==同时工作。

&emsp;&emsp;这款收集函数是以获取最短回收停顿时间为目标的收集器。目前很多java应用集中在互联网站或者B/S系统的服务端，这类应用尤其注重服务的响应速度，系统系统停顿时间越短越好，这种类型的应用就适合用CMS收集器。

&emsp;&emsp;CMS收集器使用的是**标记-清理**的算法。运作过程较之前的收集器要复杂

。一点。分为4个步骤：

1. 初始标记(CMS initial mark)  ==need stop the world==

> 初始标记只是标记以下GC Roots能直接关联到的对象，速度很快。

2. 并发标记(CMD concurrent mark)

> GC Roots Tracing的过程

3. 重新标记(CMS remark) ==need stop the world==

> 在并发标记期间其他线程仍然运行，因此重新标记是为了修正在并发标记期间因为用户程序继续运作而导致标记产生变动的那部分对象的标记记录。这个阶段耗时大于初始标记，但远小于并发标记

4. 并发清除(CMS concurrent sweep)

> 垃圾清理阶段

&emsp;&emsp;综上我们可以得知最耗时的两个阶段都是和其他线程并行运行的，因此GC停顿时间大大缩短。因此这款收集器也称为==并发低停顿收集器==。

![1542088169251](..\..\..\img\1542088169251.png)

三个缺陷:

- CMS收集器对CPU资源非常敏感，当系统CPU资源量少的时候，虽然这个算法不会导致运行停顿，但是因为这个收集器会消耗大量的CPU资源，而导致应用程序运行的变慢。
- CMS收集器无法清除浮动垃圾：原因是GC动作过程种其他线程仍在运行，新的垃圾还在不断产生，这一部分垃圾出现在标记之后，CMS无法在次GC过程中清理他们，因此这种垃圾也叫==浮动垃圾==。同时，因为其他程序还要运行，老年区必须预留一定的内存，不能像其他收集器一样，能等到老年区差不多溢出了再进行回收操作，提高了内存的资源利用率。在JDK1.5版本中，默认是老年区内存使用率超过68%就触发垃圾回收操作。**XX:CMSInitiatingOccupancyFraction**参数的值来调节触发阈值。如果CMS期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure"失败，这时虚拟机将会启动==Serial Old==收集器来清理理解。
- 使用的是标记-清除算法，会产生大量的内存碎片。

#### G1(Garbage-first)收集器

&emsp;&emsp;最新一代的垃圾收集器,如下优点

- 并行和并发：充分利用CPU、多核环境的硬件优势来缩短Stop The World，部分其他收集器需要停顿java线程的GC动作，也可以用并发的方式让java程序继续运行。
- 分代收集：分代概念得以保留，但不需要配合其他收集器来进行老、生区的垃圾回收
- 空间整合：全局来看，使用的是==标记-整理==算法，从局部(两个Region)来看使用的是==复制==算法。总之，不会产生空间碎片。
- 可预测的停顿：建立可预测的停顿模型，能让使用者明确规定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不能超过N毫秒。

&emsp;&emsp;如果使用了G1收集器，则java内存堆的内存布局就和其他收集器有很大的不同，它将堆内存划分为许多大小相等独立的区域(Region)，虽然还是有新生代和老年代的概念，但两个区域已经不是物理上分开了，而是逻辑上分开了。G1收集器可以面向Region进行GC动作而不是面向全局了，它维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region，这种基于优先级的算法，能保证在有限时间内获得尽可能高的收集效率。

&emsp;&emsp;考虑一个问题，一个Region中的对象不只是引用了本Region的对象，还可能引用了其他Region的对象，怎么快速找到这些对象，G1的做法是**每个Region都维护一张Remembered Set**，虚拟机发现程序对引用(Reference)类型的数据进行写操作时，会产生一个中断写操作，检查引用的对象是否在不同的Region中，如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remember set中。当内存回收时，在GC Roots的枚举范围中加入Remembered Set就能保证不会对全堆扫描也不会有任何遗漏。

**步骤：**

1. 初始标记
2. 并发标记
3. 最终标记
4. 筛选回收

> 根据回收价值排序，选择回报最好的Region进行回收。

![1542091174249](..\..\..\img\1542091174249.png)
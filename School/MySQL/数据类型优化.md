# 数据类型的优化

## 优化原则

1. 更小的通常更好

2. 简单就好

3. 尽量避免NULL

   - 影响查询优化

   - 如果计划在列上建立索引，应该尽量避免设计成可为NULL的列

## 数字类型

### 整数类型

| **类型**      | **字节** |
| ------------- | -------- |
| **TINYINT**   | **8**    |
| **SMALLINT**  | **16**   |
| **MEDIUMINT** | **24**   |
| **INT**       | **32**   |
| **BIGINT**    | **64**   |

Mysql的整数计算一般都是使用BIGINT类型(64)，所以其他几个类型都是存储类型。

### 实数类型

| **类型**    | **字节**     |
| ----------- | ------------ |
| **FLOAT**   | **4**        |
| **DOUBLE**  | **8**        |
| **DECIMAL** | 最多65个数字 |

&emsp;&emsp;实数是带有小数部分的数字。然而它们不只是为了存储小数部分；也可以使用DECIMAL存储比BIGINT还大的整数。

&emsp;&emsp;MySQL既支持精确类型，也支持不精确类型。

&emsp;&emsp;FLOAT和DOUBLE支持标准的浮点运算进行近似计算。因为CPU自带支持浮点运算，所以计算速度比较快。和整数类型一样，MySQL默认使用DOULE类型进行计算，因此FLOAT也只是存储类型。

&emsp;&emsp;DECIMAL支持存储精确的小数，在MySQL5.0之后，开始支持精确计算，但由于CPU不支持精确计算，所以是由MySQL服务器自己实现的精确计算，运算速度不及浮点运算快。DECIMAL用4个字节存储9个数子，小数点单独用一个数字存储。比如DECIMAL(18,9),小数点两边将各存储9个数字，一共使用9个字节(4+4+1)。

​	总结，尽量只在对小数有进行精确计算是才使用DECIMAL。数据量比较大时，可以考虑用BIGINT代替DECIMAL:假设数据要精确到万分之一，可以把所有金额乘以一百万，然后将结果存储在BIGINT里面去。这样可以避免浮点计算不精确以及DECIMAL精确计算代价高的问题。

## 字符串类型

| 类型    | 特征                                                         |
| ------- | ------------------------------------------------------------ |
| VARCHAR | 存储变长字符串，使用必要的空间存储字符串，比定长更节省空间。 |
| CHAR    |                                                              |

### VARCHAR

VARCHAR需要使用1或2个额外的空间记录字符串的长度，如果字符串的最大长度<=255个字节，那么只使用一个字节表示，以此类推。比如VARCHAR(10)要11个字节的存储空间，VARCHAR(1000)要1002个字节的存储空间。

VARCHAR节省了空间，因此也提高了性能。但当UPDATE时可能使行比之前更长，这就导致需要做额外的工作。如果一个行占用的空间增长了，且当前页内没有足够的空间给它扩容，这时候不同的存储引擎的解决方案都不一样，MyISAM会将行拆成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内。

#### 为什么varchar后面默认是(255)

首先我们要知道一个概念：InnoDB存储引擎的表索引的前缀长度最长是767字节(bytes)

你如果需要建索引，就不能超过 767 bytes；utf8编码时 255*3=765bytes ,恰恰是能建索引情况下的最大值。

如果像lavavel5.3往后 使用的是utf8mb4编码，默认字符长度则应该是 767除以4向下取整，也就是191。

总结：varchar(255) 不是最优的字符长度，最优还是应该根据实际需要的来。但是这是一个保证你能少出错的一个很好的默认值



#### MySQL中采用类型varchar(20)和varchar(255)对性能上的影响



1.MySQL建立索引时如果没有限制索引的大小，索引长度会默认采用的该字段的长度，也就是说varchar(20)和varchar(255)对应的索引长度分别为20*3(utf-8)(+2+1),255*3(utf-8)(+2+1)，其中"+2"用来存储长度信息，“+1”用来标记是否为空，加载索引信息时用varchar(255)类型会占用更多的内存； （备注：当字段定义为非空的时候，是否为空的标记将不占用字节）例如，测试sql(InnoDB引擎)如下:

![img](https://blog.csdn.net/liqfyiyi/article/details/77868924)![img](https://img-blog.csdn.net/20170906171709855?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlxZnlpeWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

varchr(10)变长字段且允许NULL:10*(Character Set：utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段) 

varchr(10)变长字段且不允许NULL:10*(Character Set：utf8=3,gbk=2,latin1=1)+2(变长字段) 

char(10)固定字段且允许NULL:10*(Character Set：utf8=3,gbk=2,latin1=1)+1(NULL) char(10)固定

字段且允许NULL:10*(Character Set：utf8=3,gbk=2,latin1=1)根据这个值，就可以判断索引使用情况，特别是在组合索引的时候，判断所有的索引字段都被查询用到。

2.varchar(20)与varchar(255)都是保持可变的字符串，当使用ROW_FORMAT=FIXED创建MyISAM表时，会为每行使用固定的长度空间，这样设置不同的varchar长度值时，存储相同数据所占用的空间是不一样。

通常情况下使用varchar(20)和varchar(255)保持'hello'占用的空间都是一样的，但使用长度较短的列却有巨大的优势。较大的列使用更多的内存，因为MySQL通常会分配固定大小的内存块来保存值，这对排序或使用基于内存的临时表尤其不好。同样的事情也会发生在使用文件排序或者基于磁盘的临时表的时候。

### CHAR

CHAR是定长的：MySQL根据定长的字符串长度分配足够的空间。

总结：

VARCHAR适合最大长度比平均长度大很多的列；列的更新很少，所以碎片不是问题。

CHAR适合存储很短的字符串，且所有的值都接近一个长度。例如CHAR适合存储密码的MD5值，因为这是一个定长的值。对应经常变更的列，CHAR也比VARCHAR性能好，因为定长的CHAR类型不容易产生碎片。对于非常短的列，CHAR比VARCHAR在存储空间上也更有效率。例如用CHAR(1)来存储Y\N,使用单字节字符集需要1个字节，而使用VARCHAR(1)则需要2个字节，因为需要额外的一个字节记录长度。

<font color='red'>单字节字符集</font>:字符串长度定义的不是字节长度，而是字符数；

问题：VARCHAR(5)和VARCHAR(200)存储‘hello'的空间开销是一样的，那么使用更短的列有什么优势？

更长的列会消耗更多的内存，因为MySQL通常会分配固定的内存块来保存内部值。

**所以最好的策略是只分配真正需要的空间。**

### BINARY和VARBINARY

存储的是二进制字符串。二进制字符串存储的是字节码而不是字符。用/0填充而不是空格，对大小写敏感，比较的时候按照字节的数值比较，简单且速度快。

### BLOB和TEXT

BLOB和TEXT都是为了存储大型数据而设计的字符串数据类型，分别采用二进制和字符方式存储。

| BLOB       | TEXT       |
| ---------- | ---------- |
| TINYBLOB   | TINYTEXT   |
| SMALLBLOB  | SMALLTEXT  |
| BLOB       | TEXT       |
| MEDIUMBLOB | MEDIUMTEXT |
| LONGBLOB   | LONGTEXT   |

## 日期和时间类型

### DATETIME

存储的范围：1001-9999年，把时间封装到YYYYMMDDHHMMSS的整数中，与时区无关。使用8个字节的存储空间。

### TIMESTAMP

保存了从1970.1.1到当前的秒数，它和UNIX时间戳相同

使用4个字节，只能表示1970-2038.

可以使用FROM_UNIXTIME()函数把UNIX时间戳转换为日期；

使用UNIX_TIMESTAMP把日期转换为UNIX时间戳。

显示的值依赖时区。

总结：通常尽量使用TIMESTAMP,因为它的空间效率比DATETIME高。


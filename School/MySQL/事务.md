# <center>事务总结</center>

## 事务的基本要素

**事务的ACID特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。**

### 原子性

**要么都执行，要么都不执行。**

>通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。

### 一致性

**数据库的状态在执行该事务操作之后从一个状态改变到了另一个状态。**

> 事务在完成时，必须使所有的数据都保持一致状态（各种 constraint 不被破坏）。

### 隔离性

**由并发事务所作的修改必须与其他并发事务所作的修改隔离。**

> 事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。  换句话说，一个事务的影响在该事务提交前对其他事务都不可见。

### 持久性

**事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。**

> 数据库 ACID 中的一致性对事务的要求不止包含对数据完整性以及合法性的检查，还包含应用层面逻辑的正确。  CAP 定理中的数据一致性，其实是说分布式系统中的各个节点中对于同一数据的拷贝有着相同的值；而 ACID 中的一致性是指数据库的规则，如果 schema 中规定了一个值必须是唯一的，那么一致的系统必须确保在所有的操作中，该值都是唯一的，由此来看 CAP 和 ACID 对于一致性的定义有着根本性的区别。

## 一致性和原子性的区别

事务是一个高度抽象的概念。事务要解决的问题是如何使多次操作，对外部看起来是一个整体的操作。理想的事务是一把锁，把一个一个的事务按照队列一样排列，不过这样性能我们无法接受，因此引入了引入了MVCC (Multi-Version Concurrency Control) 的概念，MVCC本质是copy-on-write。事务的本质是什么？事务=锁+MVCC

## 怎么理解一致性

一致性是指数据处于一种语义上的有意义且正确的状态。一致性是对数据可见性的约束，保证在一个事务中的多次操作的数据中间状态对其他事务不可见的。因为这些中间状态，是一个过渡状态，与事务的开始状态和事务的结束状态是不一致的。
举个栗子，张三给李四转账100元。事务要做的是从张三账户上减掉100元，李四账户上加上100元。一致性的含义是其他事务要么看到张三还没有给李四转账的状态，要么张三已经成功转账给李四的状态，而对于张三少了100元，李四还没加上100元这个中间状态是不可见的。
那么反驳的声音来了：

1. 要么转账操作全部成功，要么全部失败，这是原子性。从例子上看全部成功，那么一致性就是原子性的一部分咯，为什么还要单独说一致性和原子性？
2. 你说的不对。在未提交读的隔离级别下是事务内部操作是可见的，这时候会出现脏读，明显违背了一致性，怎么解释？

好吧，你的疑问很有道理，也很充分，这正说明你对事务的ACID特性理解的很到位。不过，需要注意的是：

1. 原子性和一致性的的侧重点不同：原子性关注状态，要么全部成功，要么全部失败，不存在部分成功的状态。而一致性关注数据的可见性，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见。
2. 在未提交读的隔离级别下，会造成脏读，这就是因为一个事务读到了另一个事务操作内部的数据。ACID中是的一致性描述的是一个最理想的事务应该怎样的，是一个强一致性状态，如果要做到这点，需要使用排它锁把事务排成一队，即Serializable的隔离级别，这样性能就大大降低了。现实是骨感的，所以使用隔离性的不同隔离级别来破坏一致性，来获取更好的性能。

##  事务的并发问题

### 脏读

>  脏读又称无效数据的读出，是指在访问数据库中，事务T1将某一值修改，然后事务T2读取该值，T1由于某种原因撤销对该值的修改，这就导致T2所读取到的数据是无效的，这就是脏读的概念；



### 幻读

>  是指当前的事务不是独立执行的时发生的一种现象，例如事务T1对一个表中的数据进行了修改，比如这种修改涉及到了表中的“全部数据行”；同时，事务T2也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，就会发生操作事务T1的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样，一般解决幻读的方法是增加范围锁Ranges，锁定检索范围为只读，这样就避免了幻读；

### 不可重复读

>  是指在数据库访问中，一个事务范围内两个相同的查询却返回不同的数据。这是由于查询时系统中其他事务修改的提交引起的，比如事务事务T1读取某个数据，事务T2读取并修改了该数据，T1为了对读取值进行检测而再次读取该数据，便得到了不同的结果。

==**小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表**==

## MySQL事务隔离级别

| 事务隔离级别                               | 脏读 | 不可重复读 | 幻读 |
| ------------------------------------------ | ---- | ---------- | ---- |
| 读未提交（read-uncommitted）               | 是   | 是         | 是   |
| 不可重复读（read-committed）               | 否   | 是         | 是   |
| 可重复读（repeatable-read）==(MySql默认)== | 否   | 否         | 是   |
| 串行化（serializable）                     | 否   | 否         | 否   |

**查看隔离级别**

> ```mysql
> SELECT @@tx_isolation
> ```

**设置隔离级别**

> ```mysql
> set session transaction isolation level 设置事务隔离级别
> ```


# <center>索引</center>

## 1 基本概率

### 1.1 什么是索引？ 

&emsp;&emsp;一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。说起加速查询，就不得不提到索引了。

### 1.2为什么要由索引？

&emsp;&emsp;索引在MySQL中也叫做==“键”==，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能 非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。 索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高好几个数量级。 ==索引相当于字典的音序表==，如果要查某个字，如果不使用音序表，则需要从几百页中逐页去查。

&emsp;&emsp;上面所说的"键",是存储在数据结构(B-树或HASH表中的)，因此，根据索引的存储类型，可以分为两类

>1. **B型树索引(BTREE)**
>2. **哈希索引(HASH)**

**<font color="red">注：InnoDB和MyISAM存储引擎支持BTREE型索引，MEMORY存储引擎支持HASH类型索引，默认为前者索引</font>**

## 2.MySQL支持的索引

- 普通索引
- 唯一索引
- 全文索引
- 单列索引
- 多列索引
- 空间索引

**以下情况适合创建索引**

- 经常被查询的字段，即在WHERE 字句中出现的字段
- 在分组的字段，即在GROUP BY 字句中出现的字段
- 存在依赖关系的字表和父表之间的联合查询，即主键和外键字段
- 设置唯一完整性约束的字段

**以下情况不适合用索引**

- 查询中很少使用的字段
- 拥有许多重复值的字段

## 3.创建和查看索引

### 3.1. 创建和查看普通索引

&emsp;&emsp;所谓普通索引，就是在创建索引时，<font color="red">不添加任何的限制条件(唯一、非空等限制)</font>，可以创建在任何类型的字段上。

#### 3.1.1创建表时创建普通索引

**语法形式**

```mysql
CREATE TABLE table_name(
	属性名 数据类型，
    属性名 数据类型，
    ……
    属性名 数据类型
    INDEX|KEY 【索引名】(属性名 1 【(长度)】【ASC|DESC】)  #[]表示可选
);
```

#### 3.1.2 在已经存在的表上创建普通索引

**语法形式**

```mysql
CREATE INDEX 索引名
	ON 表名 (属性名 【(长度)】 【ASC|DESC】);
```

#### 3.1.3 通过SQL语句 ALTER TABLE 创建普通索引

**语法形式**

```mysql
ALTER TABLE table_name
	ADD INDEX|KEY 索引名 (属性名 【(长度)】【ASC|DESC】);
```

### 3.2 创建和查看唯一索引

&emsp;&emsp;所谓唯一索引，就是在创建索引时，限制索引的值时唯一的。通过该类型的索引可以快速查询某条记录。

 &emsp;&emsp;根据创建索引的方式，分为自动索引和手动索引
- 自动索引：为某一个字段设置主键或唯一完整性约束时，系统就会自动创建关联该字段的唯一索引。
- 手动索引：手动在表上创建索引。

#### 3.2.1 创建表时创建唯一索引

**语法形式**

```mysql
CREATE TABLE table_name(
	属性名 数据类型，
    属性名 数据类型，
    ……
    属性名 数据类型
    UNIQUE INDEX|KEY 【索引名】(属性名 1 【(长度)】【ASC|DESC】)  #[]表示可选
);
```

#### 3.2.2  在已经存在的表上创建唯一索引

**语法形式**

```mysql
CREATE UNIQUE INDEX 索引名
	ON 表名 (属性名 【(长度)】 【ASC|DESC】);
```

#### 3.2.3 通过SQL语句 ALTER TABLE 创建唯一索引

**语法形式**

```mysql
ALTER TABLE table_name
	ADD UNIQUE INDEX|KEY 索引名 (属性名 【(长度)】【ASC|DESC】);
```

### 3.3 创建和查看全文索引

&emsp;&emsp;全文索引主要关联在数据类型CHAR、VARCHAR、和TEXT的字段上，以便能够更加快速地查询数据量较大地字符串类型地字段。

<font color="red">注：只能在存储引擎为MyISAM的数据库表上创建全文索引，在默认情况下，全文索引的搜索执行方式为不区分大小写，如果全文索引所关联的字段为二进制数据类型，则以区分大小写的搜索方式执行。</font>

#### 3.3.1 创建表时创建全文索引

**语法形式**

```mysql
CREATE TABLE table_name(
	属性名 数据类型，
    属性名 数据类型，
    ……
    属性名 数据类型
    FULLTEXT INDEX|KEY 【索引名】(属性名 1 【(长度)】【ASC|DESC】)  #[]表示可选
);
```

#### 3.3.2 在已经存在的表上创建全文索引

**语法形式**

```mysql
CREATE FULLTEXT INDEX 索引名
	ON 表名 (属性名 【(长度)】 【ASC|DESC】);
```

#### 3.3.3 通过SQL语句 ALTER TABLE 创建全文索引

**语法形式**

```mysql
ALTER TABLE table_name
	ADD FULLTEXT INDEX|KEY 索引名 (属性名 【(长度)】【ASC|DESC】);
```

### 3.4 创建和查看多列索引

&emsp;&emsp;所谓多列索引,是指在创建索引时，所关联的字段不是一个字段，而是多个字段。虽然可以通过所关联的字段进行查询，<font color="red">但是只有查询条件中使用了所关联字段中的第一个字段，多列索引才会被使用</font>

#### 3.4.1 创建表时创建多列索引

**语法形式**

```mysql
CREATE TABLE table_name(
	属性名 数据类型，
    属性名 数据类型，
    ……
    属性名 数据类型
    INDEX|KEY 【索引名】(属性名 1 【(长度)】【ASC|DESC】,
                       ……
                       属性名 n 【(长度)】【ASC|DESC】)  #[]表示可选
);
```

#### 3.4.2 在已经存在的表上创建多列索引

**语法形式**

```mysql
CREATE INDEX 索引名
	ON 表明 （属性名 【(长度)】【ASC|DESC】,
	         ……
	         属性名 【(长度)】【ASC|DESC】）；
```

#### 3.4.3 通过SQL语句 ALTER TABLE 创建全文索引

**语法形式**

```mysql
ALTER TABLE table_name
	ADD FULLTEXT INDEX|KEY 索引名 (属性名 【(长度)】【ASC|DESC】,
                                  ……
                                  属性名n 【(长度)】【ASC|DESC】);
```

### 3.4 删除索引

**语法形式**

```mysql
DROP INDEX index_name
	ON table_name
```



1. 不要索引数据量不大的表，对于小表来讲，表扫描的成本并不高。
2. 不要设置过多的索引，在没有聚集索引的表中，最大可以设置249个非聚集索引，过多的索引首先会带来更大的磁盘空间，而且在数据发生修改时，对索引的维护是特别消耗性能的。
3. 合理应用复合索引，有某些情况下可以考虑创建包含所有输出列的覆盖索引。
4. 对经常使用范围查询的字段，可能考虑聚集索引。
5. 避免对不常用的列，逻辑性列，大字段列创建索引。

## 聚簇索引和非聚簇索引:

[本质区别](http://www.cnblogs.com/tutuya/articles/28685.aspx)

[深入浅出](https://www.cnblogs.com/aspwebchh/p/6652855.html)

[B-Tree](https://www.cs.usfca.edu/~galles/visualization/BTree.html)

**以一本英文课本为例，要找第8课，直接翻书，若先翻到第5课，则往后翻，再翻到第10课，则又往前翻。这本书本身就是一个索引，即“聚簇索引”。**

**如果要找"fire”这个单词，会翻到书后面的附录，这个附录是按字母排序的，找到F字母那一块，再找到"fire”，对应的会是它在第几课。这个附录，为“非聚簇索引”**

**由此可见，聚簇索引，索引的顺序就是数据存放的顺序，所以，很容易理解，一张数据表只能有一个聚簇索引。**

**聚簇索引要比非聚簇索引查询效率高很多，特别是范围查询的时候。所以，至于聚簇索引到底应该为主键，还是其他字段，这个可以再讨论。**

[https://www.cs.usfca.edu/~galles/visualization/BTree.html]: 

## B-Tree

可以使用B-Tree索引的查询类型：

以如下表为例子：

```sql
create table people(
	last_name varchar(50) not null,
    first_name varchar(50) not null,
    dob			date not null,
    gender enum('m','f') not null,
    key(last_name,first_name,dob)
);
```

- 全值匹配

  全值匹配指的是和索引中的所有列进行匹配，如查询姓名为 HONG ZHANG、出生于1960-01-01的人。

- 匹配最左前缀

  可以查询last_name为ZHANG的人，即只使用索引的第一列。

- 匹配列前缀

  可以查找所有以Z开头的姓的人，也只是用了索引的第一列

- 匹配范围值

  可以查找姓在Allen和Barrier之间的人。也只是用了列的第一列

- 精确匹配某一列和范围匹配另一列

  可以查找姓为ZHANG，名以H开头的人。即第一列last_name全匹配，first_name范围匹配。

- 只访问索引的查询

  只需要访问索引，而不需访问数据行——覆盖索引

B-Tree的限制：

- 如果不是按照索引的最左列开始查找，则无法使用索引。例如上面例子无法用该索引查找名字为Bill的人，也无法查找某个特定生日的人。
- 不能跳过索引中间的列进行查找。也就是说不能使用上面索引查询个姓和生日的人。
- 如果查询中有某个列的范围查找，则其右边的列无法使用索引优化查找。比如查找where last_name='zhang' and first_name like 'h%'  and dob='1995-03-21',这个查询只能使用索引的前两列，因为like是一个范围条件。**因此，如果范围查询有限，因为使用多个等值条件代替范围条件。**

**从而可得，索引列的顺序十分重要。**

### 哈希索引

哈希索引是将索引列通过一个哈希函数转换成一个哈希码，哈希码对应着数据的指针。

在MySQL中，只有Memory引擎显式支持哈希索引。

以如下表作为例子：

```sql
create table testhash(
	fname varchar(50) not null,
    lname varchar(50) not null,
    key using HASH(fname)
)ENGINE=MEMORY;
```

| fname | lname     |
| ----- | --------- |
| Arjen | Lentz     |
| Baron | Schwartz  |
| Peter | Zaitsev   |
| Vadim | Tkachenko |

假设哈希函数为f()

f(Arjen)=1231

f(Baron)=3123

f(Peter)=3133

f(Vadim)=2134

则哈希索引的数据结构如下

| 槽（slot) | 值（Value)       |
| --------- | ---------------- |
| 2323      | 指向第一行的指针 |
| 2458      | 指向第二行的指针 |
| 7437      | 指向第三行的指针 |
| 8784      | 指向第四行的指针 |

所以当查询语句为：

```sql
SELECT lname from testhash where fname='Peter'
```

则先用f()函数求的‘Peter’的哈希值为3133，在索引中找到第三行的指针，然后是比较第三行的值是否为‘Peter’。

索引的优缺点：

优点：索引只需存储对应的hash值，索引结构紧凑，这也让HASH索引查找的速度非常快。

缺点：

- 哈希索引只包括哈希值和行指针，不存储字段值，所以不能使用索引中的值来避免读取行。
- 哈希索引数据不是按照索引的值顺序存储的，所以不能用于排序。
- 哈希所以不支持部分索引匹配查找。因为哈希索引是使用索引列的全部内容来计算哈希值的。比如索引为（A,B),则查询A=***的条件不能用到该索引。
- 哈希索引只支持等值比较查询，不支持范围查询。
- 存在哈希冲突的可能。
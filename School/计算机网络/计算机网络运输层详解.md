---
typora-copy-images-to: ..\..\img
---

运输层和应用层一样，只运行在端系统上，而不涉及网络的中间部分(路由器、交换机)中，应用层的报文经过套接字(socket)转交给运输层，形成报文段，最后交付给提供“尽力而为交付”服务的IP层。

而在运输层，需要考虑的几个问题是：

1. 接收方如何知道接收到的报文应该上传给哪个应用程序
2. 如果应用对报文缺失很敏感，如何在不可靠服务的IP协议基础上实现可靠运输服务

而针对第一个问题，运输层的解决方案是**多路复用和多路分解**，而针对第二个问题，解决方案则是大名鼎鼎的**可靠数据运输协议**。

当前运输层提供服务的两个协议是**UDP**(user data protocol，用户数据报协议)和**TCP**(transmission control protocol 传输控制协议)

## 1.多路复用和多路分解

&emsp;&emsp;我运输层是为所用的应用数据服务的，而每一个应用程序，都会用对应的套接字，即所用应用层的程序通过它们对应的套接字将数据下发到运输层，最后，接受方的运输层接收到数据，并将数据上传给上层的应用软件，如下图所示。

![1562743832305](..\..\img\1562743832305.png)

&emsp;&emsp;而其中的一个问题是，接受方如何知道该数据要上传给哪个应用程序。运输层会在报文段里面增加几个字段，接受方通过识别这些字段标识出接收套接字，从而将数据定向到套接字。这里面，识别运输层所用接收到的报文段并定向到正确的套接字这一工作叫做**多路分解**。在源主机从不同套接字收集数据，并为每一个数据块封装上首部信息从而生成报文段，这一工作叫做**多路复用**。

&emsp;&emsp;**UDP和TCP的实现方式略有不同：**

&emsp;&emsp;1. UDP套接字由一个二元组来识别，该二元组包括目的IP地址和目的端口号。如果两个报文段的源IP地址和端口号不同，但是目的IP地址和端口号相同，那么这两个报文段将会被定向到同一个接收套接字。UDP报文段的格式如下：

![1562744654656](..\..\img\1562744654656.png)

&emsp;&emsp;2. TCP套接字由一个四元组来识别，该四元组包括源IP地址和端口号以及目的IP地址和端口号。就是说，不同的源地址和端口号，但相同的目的地址和端口号的数据，会被定向到不同套接字。TCP报文段格式如下：

![1562745036241](..\..\img\1562745036241.png)

## 2.可靠数据运输协议

&emsp;&emsp;可靠数据运输协议能够保证数据能够有序，无损的传输到接受方。现在我们假定我们是可靠数据协议开发者，从简到难，一步一步进行设计开发。

### 2.1考虑完全可靠信到的可靠数据传输：rdt1.0

&emsp;&emsp;首先，我们考虑最简单的情况，即底层信道是完全可靠的，数据在传输过程中不会损坏，丢失。此时信道更像一个先进先出的队列。下面介绍该情况下发送方和接收方的FSM(有限状态机)。横线上的内容指引起一个状态改变到另一个状态的事件。发送发等待应用层调用rdt_send(data)函数，经过套接字下放到运输层后进行打包操作，生成报文段，最后运输层调用下层的udt_send(packet)函数进行数据传送。接受方等待下层调用rdt_rcv(packet)函数，将报文段中的应用数据抽取出来，调用deliver_data(data)函数上传给对上层应用程序。显然，发送方和接收方不用考虑数据传输失败的问题，只需要循环发送/接收即可。

![1562745556233](..\..\img\1562745556233.png)

### 2.2考虑具有比特差错信道的可靠数据传输：rdt2.0

&emsp;&emsp;我们考虑数据传输过程中数据会受损(实际也是如此)，但不会丢失，且仍然按照发送顺序被接收方接收。

&emsp;&emsp;接收方收到信息后返回**肯定确认**，未收到或者收到损害信息后返回**否定确认**，需要发送者重复发送，这种协议叫做**自动重传请求**（Automatic Repeat Request,ARQ）协议。

自动重传请求需要以下几个协议作为支持：

- 差错检测：通过在报文段首部字段中增加检验和(所有比特字的进行求和，溢出则回卷，最后取反操作)
- 接收方反馈
- 重传

&emsp;&emsp;该模型的FSM如下：

![1562746986549](..\..\img\1562746986549.png)

&emsp;&emsp;我们必须要注意的是，发送方在等待接收方反馈消息(ACK、NAK)状态时，它不能从上层获得更多的数据，也就是说，上层无法调用rdt_send（data）函数。这种机制，我们把它叫做<font color='red'>**停等协议**</font>。

&emsp;&emsp;但是，在这个模型中，还存在反馈信息受损的情况。当前采用的方法是，只要收到受损的反馈信息，就重传数据。可是，如果只重传数据，接收方无法分辨接收到的数据到底是新数据还是重传的数据。因此，在这个基础上，在报文段的首部新增了一个字段:**序号字段**。接收方通过检测序号则可以知道收到的分组是重传数据还是新数据。这样就演化到了**rdt2.1**:**数据增加序号字段**，因为使用的是停等机制，因此序号字段使用1比特即可

#### 2.2.1 rdt2.1**:**数据增加序号字段

其FSM如下：

![1562748456555](..\..\img\1562748456555.png)

![1562748557386](..\..\img\1562748557386.png)

#### 2.2.2 rdt2.2 无NAK

在之前的模型中，ACK表示肯定确认，NAK表示否定确认。而在数据有了序号之后，则可以只使用ACK进行反馈。当接受方收到一个有误数据后，对上个正确接收的数据回馈ACK，发送方如果收到了同一个分组的两个ACK(即冗余ACK),发送方就知道接受方没有接收到跟在被确认两次的分组后面的分组。因此，使用这种模型，发送方需要知道接收到的ACK是对哪个数据的回馈，因此，ACK需要被标上序号。FSM如下：

![1562748942290](..\..\img\1562748942290.png)

![1562748974692](..\..\img\1562748974692.png)

### 2.3 考虑具有比特差错的丢包信道的可靠数据传输：rdt3.0

&emsp;&emsp;之前都没有考虑数据丢包问题，而实际网络中如果存在拥塞现状，某个路由器的缓存溢出，会导致数据丢包情况方式，而丢包情况可能发生在数据传输过程，也可能发生在回馈消息传输过程。

&emsp;&emsp;数据丢包后，发送方无法接收到回馈消息，因此无法跳转到下一个状态。所以，为了解决这个问题，增加了一个新的机制，定时器。发送方在一段时间内还没有收到回馈消息，则自动重传。那么以下几种情况会引发超时重传。

1. 数据包丢失，自动重传
2. ACK 丢失，自动重传，信道中引入了冗余数据分组
3. ACK和数据都没丢失，网络拥堵延迟过大才导致定时器超时，信道中引入了冗余数据分组。

不过，在rdt2.2中，通过序号已经能够解决冗余分组问题。

![1562749863419](..\..\img\1562749863419.png)

![可靠运输协议2](..\..\img\可靠运输协议2-1562749890485.png)



&emsp;&emsp;到这里，一个考虑具有比特差错的丢包信道的可靠数据传输协议就完成了，可惜，它基于停等协议。它的缺陷是每个RTT只能传输一个分组，吞吐量过低。而现实中，都是采取**流水线可靠数据传输**协议(一次发送多个分组)

## 3.流水线可靠数据传输协议

使用流水线技术对可靠运输协议的影响：

1. 需要增到序号范围，因为每个输送的分组必须有一个唯一的序号，而且同一时刻有多个在运输中但未被确认的报文
2. 发送方和运输方也必须缓存多个分组。发送方至少需要缓存那些已发送但未确认的分组。接收方或许需要缓存那些已被正确的接收的分组。下面会讨论到。
4. 所需序号的范围和对缓存的要求取决于流水线的策略。当前采取的两个策略有：回退N步(Go-Back-N,GBN)和选择重传(Selective Repeat,SR)

### 3.1 回退N步(GBN)

&emsp;&emsp;该协议运行发送方一次性发送多个分组而不需要等待确认，但它也受限有窗口大小N，即已发送但未确认分组的最大数量。下图表示GBN协议的发送方的序号范围。基序号(base)定义为最早的未确认分组的序号，将下一个序号(nextseqnum)表示为最小的未使用序号。随着协议的运行，该窗口在序号空间向前滑动，因此，GBN也称为**滑动窗口协议**。

![1562751482469](..\..\img\1562751482469.png)

&emsp;&emsp;GBN的策略是，接收方如果接收到正确且有序的分组，则返回对该分组的ACK确认，在其他情况，**一律丢弃分组，并返回最近按序接收到的分组的ACK确认**。发送方等待base分组超时后，重传所有已发送但未确认的数据，因此，定时器只需要定时base指向的元组，即最早发送但未确认的元组。同时，GBN引入了**累计确认**策略，即如果发送方接收到了序号为n分组的确认信息，则表明序号<n的所有事件都被正确接收。

该算法的FSM:

![1562752184494](..\..\img\1562752184494.png)

![1562752603492](..\..\img\1562752603492.png)

**GBN协议运行示意图：**

![1562752692630](..\..\img\1562752692630.png)

### 3.2 选择重传(SR)

&emsp;&emsp;在GBN中，所有失序的分组都会被丢弃，这样的带宽利用率过大。而SR则是只重传传输失败的分组。因此，接受方会对正确接收但失序的元组返回ACK，并进行缓存，直到所有的丢失分组(即序号更小的分组)皆被接收到在，才上传给上传应用。采用这种方法，对每一个已发送但未确认的元组都需要用一个定时器进行计时。

![1562758979748](..\..\img\1562758979748.png)

&emsp;&emsp;从上图a可以看到，send_base之后的元组可以被确认。当收到ACK时，如果该分组序号在窗口以内，则对该分组标记为已接受，如果该分组的序号==send_base，那么send_base向又移动到序号最小的已发送但未接收分组处。在移动过程中如果有等待发送落到了窗口处，则发送该分组。

&emsp;&emsp;上图b是接受方的窗口视角。如果接收到序号为[rcv_base,rcv_base+N-1]序号的分组，则返回ACK。如果接收到的是[rcv_base-1,rcv_base+N-1],则进行缓存并返回ACK。如果收到分组的序号是rcv_base,则将该分组以及以前缓存的连续分组交付给上层，同时移动rcv_base。存在一种可能的情况是，接收到[rcv_base-N,rcv_base-1]的分组，这种情况下必须返回一个对应的ACK，因为发送方等不到这个ACK,窗口无法进行滑动。



## 4. TCP:面向连接的运输

&emsp;&emsp;TCP是拥有可靠运输传输协议和拥塞控制的传输协议，在发送数据前，需要进行三次握手，双方维持发送缓存和接收缓存以及一些变量。

&emsp;&emsp;TCP传输数据的大小受限于MSS(Maximum Segment Size)最大报文段长度。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度MTU(Maximum Transmission Unit)决定。设置该MSS要保证在加上TCP/IP首部字段后小于MTU。注意到MSS是值报文段里应用层数据的最大长度而不是加上TCP首部后的最大长度。再次回顾TCP报文段的结构

![1562745036241](..\..\img\1562745036241.png)

| 元素                  | 含义                   |
| --------------------- | ---------------------- |
| sequence number       | 序号                   |
| Acknowledgment number | 确认号                 |
| Header length         | 首部长度               |
| SYN FIN RST           | 握手有关               |
| Receive Window (rcwd) | 接收窗口，用于流量控制 |
| internet checksum     | 检验和                 |
| options               | 选项                   |
| Data                  | 应用层数据             |

&emsp;&emsp;**TCP中的序号使用的是字节流序号而不是分组序号**，它是发送数据的首字节编号。比如下图，第一个报文段的序号是0，第二个的序号是1000，第三个的序号是2000.

![1562760413702](..\..\img\1562760413702.png)

&emsp;&emsp;而确认号是接收方是接收方期待从发送方收到的下一字节的序号。比如上图中接收方对第一个报文段的确认号是1000，第二个报文段的确认号是2000。

### 4.1TCP的流水线协议(selective acknowledgment)选择确认

&emsp;&emsp;上面说了确认号是接收方填充进报文段确认号是接收方期待从发送方收到的下一字节的序号。比如接收方收到了0-535字节的报文段，则它返回报文段的确认号是536。而后，接收方收到了900-1000字节的报文段，却没有收到539-899的报文段，此时，TCP仍然返回确认号为536的报文段。因为TCP只确认该流中至第一个丢失字节为止的字节，即：**TCP和GBN一样，采用了累积确认机制。**而接收到正确但失序的报文段时，是丢弃还是缓存由开发者决定。实践中采用了和SR一样的策略，缓存下来，直到丢失字节收到一起交付到上层。因此TCP的流水线协议是GBN和SR的综合版本：选择确认。

### 4.2 TCP超时重传时间设定

TCP会在任意时刻测量RTT(重传报文除外)时间：$sampleRTT$，平均RTT时延计算公式
$$
\text { EstimatedRTT }=(1-\alpha) \cdot \text { EstimatedRTT }+
\alpha \cdot \text { Sample }  \mathrm{RTT}
\
$$
同时，TCP会计算RTT波动$DevRTT$:
$$
\text {DevRTT}=(1-\beta) \cdot \text { DevRTT }+\beta \cdot | \text { SampleRTT }-\text { EstimatedRTT } |
$$
那么超时重传时间设定为：
$$
\text {TimeoutInterval}=\text { EstimatedRTT }+4 \cdot \text{DevDTT}
$$
$TimeoutInterval$初始设置为1s,出现超时后会翻倍，一旦采集SampleRTT并更新了EstimatedRTT后,则按照该公式进行计算

### 4.3 TCP的快速重传机制

当TCP收到对相同数据的3个冗余ACK时，TCP把它当作一个暗示，说明跟在这个被确认过4次的报文段之后的报文段以及丢失，此时不用等待超时中断，立即重传后面的数据。该机制称为快速重传机制。

### 4.4 TCP的三次握手协议

1. 客户端发送一个特殊的报文段，该报文段的应用层数据为空，但SYN置为1.同时，随机选取一个数字作为初始序号client_isn，放入序号字段中
2. 服务段接收了SYN报文段，如果主机没有开启报文段中的目标端口号，则返回RST报文段(RST置为1),即通知客户端该端口未开启，别在给我连接了。否则，服务端也返回一个SYN报文段，服务端选择自己的初始序号server_isn放入序号字段中，同时将确认字段设置为client_isn+1;同时，服务端需要在第三次握手之前初始化接受缓存和变量
3. 客户端如果收到了RST报文段，则放弃连接。如果收到的时SYN报文段，则也要给该连接分配发送缓存和变量。同时发送这第三个报文段，该报文段将SYN置为0，因为连接已经建成，其确认字段置为server_isn+1，并且可以携带应用层数据。

#### **4.4.1为什么要三次握手？**

&emsp;&emsp;客户端向服务端发送SYN报文段请求连接，当服务端正确接收后，服务端得知：客户端有发送数据的能力，但是如果服务端不进行响应，发送端不确定服务端有正常发送和接受消息的能力。因此，当客户端接收到了服务端的响应SYN报文段后，客户端得知了服务端具有正常发送和接受消息的能力。但此时，服务端还并不知道客户端有正常接受消息的能力。客户端对服务端运行连接的报文段反馈后，双方才都得知对方有正常接收和发送消息的能力。

&emsp;&emsp;不仅如此，三次握手运行发送方和接收方建立所需的状态信息(例如，序号和初始流控制窗口长度rwnd)

&emsp;&emsp; 谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。**本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。**采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。**主要目的防止server端一直等待，浪费资源。**

#### 4.4.2 SYN洪泛攻击

&emsp;&emsp;4.4.1提到过，服务端会在第三次握手之前分配好缓存和变量。经典的Dos攻击即SYN洪泛攻击，抓住了这个漏洞，发送大量的SYN请求连接报文，却不完成第三次握手的步骤。服务端充斥着大量的半开半连接的缓存和变量。导致资源消耗殆尽，无法响应正常的TCP连接。

&emsp;&emsp;而一个有效的解决方法是，SYN cookie。它工作机制如下:

&emsp;&emsp;服务端接收到SYN连接请求时，不会马上分配缓存，而是根据TCP报文段的源和目的IP地址与端口号以及仅有该服务器知道的秘密数的散列函数生成一个初始序列号“cookie”。但服务器并不记录该cookie，而是将该cookie放到响应连接SYN报文段的序号字段中。正常的TCP连接在第三次握手中会将cookie+1作为确认字段发送到服务端，服务端重新计算cookie+1，判断是否等于该报文段的确认字段。如果相等，才创建一个具有套接字的全开联接。

![1564539352294](..\..\img\1564539352294.png)



### 4.5 TCP的四次挥手协议

当客户想释放连接时，向服务器发送特殊报文段:FIN报文段(FIN标志为设为1)，服务端收到后返回ACK报文段。然后服务端发送字节的终止报文段：FIN报文段，最后客户端对这个终止报文段进行确认。此时，在两台主机上所有的资源都被释放了。

![1562815321594](..\..\img\1562815321594.png)

#### 4.5.1为什么需要4次挥手

首先，TCP是一个可靠数据运输协议，即该全双工的连接要保证客户端和服务端发送的数据能准确有序的被对方收取。当客户端申请中断连接是，向服务器发送终止连接信息：FIN报文段，表明我这边是没有数据要发送了。服务端接收到客户端的终止连接信号后，服务端知道了客户端没有数据要传输了。但是，如果就到这里结束了，客户端不知道服务端还有没有数据要传输，如果冒然关闭连接，加入服务端还有数据在传输，那这些数据就被丢失了。因此，当服务端数据传输完成后，还要向客户端发送终止连接报文段，告诉客户端，我这边的数据也传输完了，可以关闭连接了。因此，要保证TCP连接能安全解除，必须需要4次挥手机制



![img](https://upload-images.jianshu.io/upload_images/4181927-67508b0624c78bc3.png?imageMogr2/auto-orient/strip|imageView2/2/w/801/format/webp)

客户端和服务端TCP状态序列：

![1567392335975](..\..\img\1567392335975.png)

![1567392366898](..\..\img\1567392366898.png)

#### [4.5.2 TIME_WAIT状态存在的理由](https://www.cnblogs.com/softidea/p/5741192.html)

TCP/IP协议就是这样设计的，是不可避免的。主要有两个原因:

1. 可靠地实现TCP全双工连接的终止

   TCP协议在关闭连接的四次握手过程中，最终的ACK是由主动关闭连接的一端（后面统称A端）发出的，如果这个ACK丢失，对方（后面统称B端）将重发出最终的FIN，因此A端必须维护状态信息（TIME_WAIT）允许它重发最终的ACK。如果A端不维持TIME_WAIT状态，而是处于CLOSED 状态，那么A端将响应RST分节，B端收到后将此分节解释成一个错误（在java中会抛出connection reset的SocketException)。

   因而，要实现TCP全双工连接的正常终止，必须处理终止过程中四个分节任何一个分节的丢失情况，主动关闭连接的A端必须维持TIME_WAIT状态 。 

2. 允许老的重复分节在网络中消逝 

   TCP分节可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个迟到的迷途分节到达时可能会引起问题。在关闭“前一个连接”之后，马上又重新建立起一个相同的IP和端口之间的“新连接”，“前一个连接”的迷途重复分组在“前一个连接”终止后到达，而被“新连接”收到了。为了避免这个情况，TCP协议不允许处于TIME_WAIT状态的连接启动一个新的可用连接，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中消逝。

MSL就是maximum segment lifetime(最大分节生命期），这是一个IP数据包能在互联网上生存的最长时间，超过这个时间IP数据包将在网络中消失 。MSL在RFC 1122上建议是2分钟，而源自berkeley的TCP实现传统上使用30秒。

 

TIME_WAIT状态维持时间

\----------------------------

TIME_WAIT状态维持时间是两个MSL时间长度，也就是在1-4分钟。Windows操作系统就是4分钟。

### 4.6 流量控制机制

流量控制服务的目的时消除发送方使缓存方溢出的可能性。接收方定义了两个变量：

- LastByteRead:主机B上的应用进程从缓存中读出的最后一个字节的编号
- LastByteRecvd：从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个字节的编号

那么接收方的**接收窗口**Receive Window (rcwd)定义为：

$rcwd=RcvBuff-(LastByteRecvd-LastByteRead)$

而发送方维持两个变量：

- LastByteSend:最后一个发送字节的编号
- LastByteAcked：最近接收到确认的字节编号

要保证接收方缓存不溢出，只需要保持：

$rcwd>=LastByteSend-LastByteAcked$

即已发送但未确认的报文段字节总长度<=接收缓存的剩余缓存，因此TCP报文结构中的rcwd字段就是用来传输接收方的rcwd信息。

![1562815128195](..\..\img\1562815128195.png)

### 4.7 TCP的拥塞控制

&emsp;&emsp;TCP发送方也会因为IP网络的拥塞而被遏制，这种遏制叫做拥塞控制。与流量控制不同，流量控制关注的仅仅时发送方和接收方，而拥塞控制关注的时整个网络的全局状况。

&emsp;&emsp;TCP的每一端都维持发送缓存，接收缓存和几个变量,如4.5介绍的，运行在发送方的TCP拥塞控制机制跟踪一个额外的变量，即流量窗口(Congestion Window,cwnd)。TCP要保证发送方的发送速率满足：
$$
\text{LastByteSend}-\text{LastByteAsked}\leq \min \{\text { cwnd, }, \text { rwnd }\}
$$
而拥塞控制算法主要由三部分组成：

1. 慢启动
2. 拥塞避免
3. 快速恢复

其FSM图如下所示：
![1562765930652](..\..\img\1562765930652.png)

&emsp;&emsp;cwnd初始值通常设置为一个MSS,当收到一个ASK时，cwnd翻倍，因此，在慢启动阶段，cwnd呈指数增加，当出现丢包引发超时时，设置慢启动阈值ssthresh=cwnd/2，并把cwnd重新设置为一个MSS。之后当cwnd>=ssthresh之后，不再采用翻番策略，而是转移到拥塞避免模式，每次收到一个ACK,只增加一个MSS。而快速恢复这一步是建议选项，算法可以按需采纳。当收到对同一个数据的3个冗余ACK时，说明数据丢失，但对于这种情况，TCP的应对策略并没有超时指示的丢包那么强烈，因为它不一定象征着网络此时很拥塞。因此采取的策略是，cwnd=cwnd/2+3MSS（因为受到了3个冗余的ASK），最终，当对丢失报文的ACK到达时，TCP在降低cwnd后在进入拥塞避免状态。
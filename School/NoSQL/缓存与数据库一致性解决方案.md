---
typora-copy-images-to: ..\..\img
---



## 更新缓存还是删除缓存

### 更新缓存

每次更新数据库后就同步更新缓存，不存在miss情况

### 删除缓存

对数据进行更新时先直接删除缓存中对应的数据，等下次查询时，将数据重新填充缓存

缓存和数据库应该先操作谁

### 取舍

> 对于一些修改次数多的应用，导致数据还未查询就一直在修改，浪费CPU资源。且如果缓存中的数据和数据库中的值并不对于，缓存中的值是经过多个数据库中的数据一起计算得到，则更新代价很大，因此通常情况下的措施都是删除缓存，这样的代价仅仅是一次查询miss。

## [缓存和数据库先操作谁](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=404087915&idx=1&sn=075664193f334874a3fc87fd4f712ebc&scene=21#wechat_redirect)

### 如果先更新数据库再删除缓存

案例：

![img](http://mmbiz.qpic.cn/mmbiz/YrezxckhYOyR7CQ7rQic03drREJm157sg6CAcHNibRJeZPlIhWPWZtkH6o0a3I33IljtKDkf4By4tUOqPycwCZ9A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

A 执行数据1的写操作

B执行数据1的读操作

A修改数据库成功，但删除缓存失败，导致数据库和缓存不一致

B读取数据1，缓存命中，读取的是脏数据

### 如果先删除缓存再更新数据库

![img](http://mmbiz.qpic.cn/mmbiz/YrezxckhYOyR7CQ7rQic03drREJm157sgYYRGCjSgNzz8HlLkU4c00gbtibibhlsBqWDjyR0L8GW9HibeNUaOQVY7A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

案例1：

线程A更新数据，缓存删除成功，数据库更新失败，此时只会有一次缓存miss，不会造成数据不一致性。

### 结论：先删除缓存再更新数据库

根据上面两个案例，先更新数据库的话会造成缓存和数据库的不一致性。因此，实践中选择先删除缓存再更新数据库

案例：

A执行数据1的写操作 

B执行数据1的读操作

A删除数据库的缓存1

B读取数据库的缓存，缓存Miss

B去数据库读取数据，此时的A还未更新数据库，导致B读取的数据是旧数据，并再次用旧数据填满缓存

A更新数据库

## [单库应用程序](https://blog.csdn.net/qq_27384769/article/details/79499373)

1. 如果并发数很低，读写并发造成不一致性的情况很低，则可以设置缓存的有效时间，最坏的情况也是在有效期之内。

2. 如果并发数高，会导致这种情况产生

   ![1567239390807](C:\Users\fanxin\AppData\Roaming\Typora\typora-user-images\1567239390807.png)

   > 1. A执行数据1的写操作 ，先删除缓存
   >
   > 2. A发出修改数据库请求
   >
   > 4. B读取数据库的缓存，缓存Miss
   >
   > 5. B去数据库读取数据，此时的A还未更新数据库，导致B读取的数据是旧数据，并再次用旧数据填满缓存，造成一致性破坏。

### 解决办法：串行化

保证对同一个数据的操作按照请求的先后数据执行。

1. 使用请求队列，将任务放到请求列队中

   > 因为一个现在都是多线程程序，即使使用请求队列也不能保证操作的一致性
   >
   > 案例：
   >
   > 请求A进行数据1写操作，放入请求队列
   >
   > 请求B进行数据1读操做，放入请求队列
   >
   > 线程A读取请求A
   >
   > 线程B读取请求B
   >
   > 线程A删除缓存数据，CPU分配的时间片到了，切换到线程B
   >
   > 线程B查询数据1，发现缓存中没有，去数据库中查询并将数据放入缓存中，造成数据不一致

2. 如果对用一个数据的操作使用同一个数据库连接，就能解决上述问题

   > 先对数据库连接设置序号，比如根据id对user进行更新，对id进行取模得到数据库连接序号，即对相同id操作的请求都使用同一个数据库连接操作，则可以保证数据库的操作是按照请求的顺序来的。

   但是，如果同一个服务有多个部署的情况下，又不能满足串行问题了，每个服务模块都有一个请求队列，同一个服务模块中的对同一个数据的操作会按照请求的顺序来执行，但不能保证整个系统中对数据的操作顺序按照请求发出的时间顺序来完成。

3. 为了解决2遗留的问题，可以通过把对相同数据的请求发送给同一服务模块的同一个数据库连接完成。

   > 对同一个功能模块的多个服务设置序号，service1,service2...，当某一个服务要对id为A的进行修改时，对NUM取模，得到实际执行该操作的服务id：B，使用RPC将请求发送给个B，B收到后放到请求队列，拿出请求后，再对A取模，获取对应的数据库连接，执行操作

## [主从同步，读写分离](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=404308725&idx=1&sn=1a25ce76dd1956014ceb8a011855268e&scene=5&srcid=0324cRvj2fkk2g8Jhn0pRXpl#rd)

![1567242118204](..\..\img\1567242118204.png)

对用写少读多的应用，[可以使用主从同步，读写分离的思路](https://www.cnblogs.com/liluxiang/p/9679279.html)，写操作全部面向主库，主库再同步到从库，读操作全部面向从库。

![img](http://mmbiz.qpic.cn/mmbiz/YrezxckhYOwaiaLOJAcZRoSIibo4Q92VtzInaialV7eXiaJ3icTyo0RCLvKia97xePx5FSF42r6W4KvA1VpcydRfXbAA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

1）请求A发起一个写操作，第一步淘汰了cache，如上图步骤1

2）请求A写数据库了，写入了最新的数据，如上图步骤2

3）请求B发起一个读操作，读cache，cache miss，如上图步骤3

4）请求B继续读DB，读的是从库，此时主从同步还没有完成，读出来一个脏数据，然后脏数据入cache，如上图步4

5）最后数据库的主从同步完成了，如上图步骤5

这种情况**请求A和请求B的时序是完全没有问题的，是主动同步的时延**（假设延时1秒钟）中间有读请求读从库读到脏数据导致的不一致。

 这时候串行化就解决不了了，那怎么来进行优化呢？

### 不一致优化思路

有同学说“那能不能先操作数据库，再淘汰缓存”，这个是不行的，上面介绍过

 出现不一致的根本原因：

（1）单库情况下，服务层在进行1s的逻辑计算过程中，可能读到旧数据入缓存

（2）主从库+读写分离情况下，在1s钟主从同步延时过程中，可能读到旧数据入缓存

既然旧数据就是在那1s的间隙中入缓存的，**是不是可以在写请求完成后，再休眠1s，再次淘汰缓存**，就能将这1s内写入的脏数据再次淘汰掉呢？

答案是可以的。

 写请求的步骤由2步升级为3步：

（1）先淘汰缓存

（2）再写数据库（这两步和原来一样）

（3）休眠1秒，再次淘汰缓存

这样的话，1秒内有脏数据如缓存，也会被再次淘汰掉，但带来的**问题**是：

（1）所有的写请求都阻塞了1秒，大大降低了写请求的吞吐量，增长了处理时间，业务上是接受不了的

 再次分析，其实第二次淘汰缓存是“为了保证缓存一致”而做的操作，而不是“业务要求”，所以**其实无需等待，用一个异步的timer，或者利用消息总线异步的来做这个事情即可**：

![img](http://mmbiz.qpic.cn/mmbiz/YrezxckhYOwaiaLOJAcZRoSIibo4Q92VtzOhiaN9mHjjiaIkavOFHu0wBEZEPGX6zwQib4xpwtg8veCq1QLPWa3b4JA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
写请求由2步升级为2.5步：

（1）先淘汰缓存

（2）再写数据库（这两步和原来一样）

（2.5）不再休眠1s，而是往消息总线esb发送一个消息，发送完成之后马上就能返回

这样的话，写请求的处理时间几乎没有增加，这个方法淘汰了缓存两次，因此被称为“缓存双淘汰”法。这个方法付出的代价是，缓存会增加1次cache miss（代价几乎可以忽略）。

 而在下游，有一个异步淘汰缓存的消费者，在接收到消息之后，asy-expire在1s之后淘汰缓存。这样，即使1s内有脏数据入缓存，也有机会再次被淘汰掉。

 上述方案有一个**缺点**，需要业务线的写操作增加一个步骤，**有没有方案对业务线的代码没有任何入侵呢**，是有的，这个方案在[《细聊冗余表数据一致性》](http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=403963671&idx=1&sn=51a2d2fd70212451cd5f22bbe2c6f8d6&scene=21#wechat_redirect)中也提到过，通过分析线下的binlog来异步淘汰缓存：

![img](http://mmbiz.qpic.cn/mmbiz/YrezxckhYOwaiaLOJAcZRoSIibo4Q92VtzQODWqiaSo1SFqxEIp8YrbWEbx7NnOGUSWRc7w23nQWia1E8ayicWVhjHQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
业务线的代码就不需要动了，新增一个线下的读binlog的异步淘汰模块，读取到binlog中的数据，异步的淘汰缓存。

 **提问：为什么上文总是说1s，这个1s是怎么来的？**

回答：1s只是一个举例，需要根据业务的数据量与并发量，观察主从同步的时延来设定这个值。例如主从同步的时延为200ms，这个异步淘汰cache设置为258ms就是OK的。

 

## **四、总结**

在“异常时序”或者“读从库”导致脏数据入缓存时，可以用**二次异步淘汰**的“**缓存双淘汰**”法来解决缓存与数据库中数据不一致的问题，具体实施至少有三种方案：

（1）**timer异步淘汰**（本文没有细讲，本质就是起个线程专门异步二次淘汰缓存）

（2）**总线异步淘汰**

（3）**读binlog异步淘汰**


# 虚拟内存与物理内存的联系与区别

2018年08月30日 11:55:36  更多



版权声明：本文为博主原创文章，遵循[ CC 4.0 BY-SA ](http://creativecommons.org/licenses/by-sa/4.0/)版权协议，转载请附上原文出处链接和本声明。本文链接：https://blog.csdn.net/lvyibin890/article/details/82217193

操作系统有虚拟内存与物理内存的概念。在很久以前，还没有虚拟内存概念的时候，程序寻址用的都是物理地址。程序==能寻==址的范围是有限的，这取决于CPU的地址线条数。比如在32位平台下，寻址的范围是2^32也就是4G。并且这是固定的，如果没有虚拟内存，且每次开启一个进程都给4G的物理内存，就可能会出现很多问题：

- 因为我的物理内存时有限的，当有多个进程要执行的时候，都要给4G内存，很显然你内存小一点，这很快就分配完了，于是没有得到分配资源的进程就只能等待。当一个进程执行完了以后，再将等待的进程装入内存。这种频繁的装入内存的操作是很没效率的
- 由于指令都是直接访问物理内存的，那么我这个进程就可以修改其他进程的数据，甚至会修改内核地址空间的数据，这是我们不想看到的
- 因为内存时随机分配的，所以程序运行的地址也是不正确的。

于是针对上面会出现的各种问题，虚拟内存就出来了。

在之前一篇文章中[进程分配资源](https://blog.csdn.net/lvyibin890/article/details/82193900)介绍过一个进程运行时都会得到4G的虚拟内存。这个虚拟内存你可以认为，每个进程都认为自己拥有4G的空间，这只是每个进程认为的，但是实际上，在虚拟内存对应的物理内存上，可能只对应的一点点的物理内存，实际用了多少内存，就会对应多少物理内存。

进程得到的这4G虚拟内存是一个**连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换。**

进程开始要访问一个地址，它可能会经历下面的过程

1. 每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址
2. 所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上
3. 进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过页表来记录
4. 页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）
5. 当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常
6. 缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。

 

关于虚拟内存与物理内存的联系，下面这张图可以帮助我们巩固。

![img](https://img-blog.csdn.net/20180830111258836?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x2eWliaW44OTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 页表的工作原理如下图

![img](https://img-blog.csdn.net/20180830114901391?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x2eWliaW44OTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

1. 我们的cpu想访问虚拟地址所在的虚拟页(VP3)，根据页表，找出页表中第三条的值.判断有效位。 如果有效位为1，DRMA缓存命中，根据物理页号，找到物理页当中的内容，返回**。**
2. 若有效位为0，参数缺页异常，调用内核缺页异常处理程序。内核通过页面置换算法选择一个页面作为被覆盖的页面，将该页的内容刷新到磁盘空间当中。然后把VP3映射的磁盘文件缓存到该物理页上面。然后页表中第三条，有效位变成1，第二部分存储上了可以对应物理内存页的地址的内容。
3. 缺页异常处理完毕后，返回中断前的指令，重新执行，此时缓存命中，执行1。
4. 将找到的内容映射到告诉缓存当中，CPU从告诉缓存中获取该值，结束。

 

### 再来总结一下虚拟内存是怎么工作的

当每个进程创建的时候，内核会为进程分配4G的虚拟内存，当进程还没有开始运行时，这只是一个内存布局。实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射）。这个时候数据和代码还是在磁盘上的。当运行到对应的程序时，进程去寻找页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生缺页异常，于是将磁盘上的数据拷贝到物理内存中。

另外在进程运行过程中，要通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。

可以认为虚拟空间都被映射到了磁盘空间中（事实上也是按需要映射到磁盘空间上，通过mmap，mmap是用来建立虚拟空间和磁盘空间的映射关系的）

 

### 利用虚拟内存机制的优点 

1. 既然每个进程的内存空间都是一致而且固定的（32位平台下都是4G），所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际内存地址，这交给内核来完成映射关系
2. 当不同的进程使用同一段代码时，比如库文件的代码，在物理内存中可以只存储一份这样的代码，不同进程只要将自己的虚拟内存映射过去就好了，这样可以节省物理内存
3. 在程序需要分配连续空间的时候，只需要在虚拟内存分配连续空间，而不需要物理内存时连续的，实际上，往往物理内存都是断断续续的内存碎片。这样就可以有效地利用我们的物理内存

 

# 分页内存管理——虚拟地址到物理地址的转换

2018年08月10日 23:30:57  更多



版权声明：本文为博主原创文章，遵循[ CC 4.0 BY-SA ](http://creativecommons.org/licenses/by-sa/4.0/)版权协议，转载请附上原文出处链接和本声明。本文链接：https://blog.csdn.net/qq_40780910/article/details/81570439

> # 前言：

​         此篇博客内容在于着重帮助读者明白在分页内存管理下，虚拟地址和物理地址转换计算是怎么进行的。

​         有关分页内存管理的其他知识请事先参阅有关资料。^_^

 

在计算之前需要了解如下知识：

  ①

 对每个程序而言，就好像自己独占了内存空间从0到极限的计算机。虚拟地址都是以0开始到某个上限结束。

这是因为某个程序在何种硬件设备的机器上运行并不能事先确定（因为写出来的程序一般都会在很多计算

 机上运行，而每台计算机的内存占用情况事先肯定无法知晓），操作系统自然不可能对症下药地发出对于某

 台机器的物理主存地址。因此，指令里面的地址是程序空间（虚拟空间）的虚拟地址（程序地址）。所以当

 程序真正运行起来的时候，每个虚拟地址必然要对应着一个物理地址（实际存在）。既然要对应，那就比如存

在某种对应机制。

  ②

分页内存管理机制将虚拟内存和物理内存都分成大小一样大的部分，我们称为页，然后按页进行内存分配，

一般页的大小有4KB、8KB、16KB。在该管理机制下内存分配单位化而且不需要空闲连续在一起即可使用

（比如第四页和第8页都空闲则可以组合起来给一个程序使用，但在分页内存管理发明之前是不可以的，因

 为两段空间不连续，至于为什么~~~~~~此处不予解释，需要了解的同学可以参阅相关资料。）

 

③

虚拟地址的页号表示和物理地址页号表示是从0开始的。

（比如虚拟地址的第1页前面还有第0页，这个对理解计算非常重要）。

 

④

理解了上面几点知识就可以尝试理解如下图表：（了解页表是什么即可。）

![img](https://img-blog.csdn.net/20180810222925668?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNzgwOTEw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

 

通过页表我们就可以发现，每个虚拟页面号都对应着一个物理页面号，比如虚拟页面号是1，查询该表

我们就可以知晓虚拟页面号1对应的物理页面号在哪里。之所以有这个表存在，就是因为我们使用的物理

内存是不连续的（参考知识点②）。

 

 

现在直接上题：

​      ![img](https://img-blog.csdn.net/20180810224137415?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNzgwOTEw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

题目给出了虚拟地址：0010 0000 0000 0100

第一步由页面大小为4KB可以得出页内偏移值为12位，也就是0010 0000 0000 0100,前面四位为页面号，

即 0010 0000 0000 0100，由此我们可以知道虚拟页面为2。

 

可能到这里有不少读者会困惑为什么是这样子计算，我以十进制数做说明。

假设一个页面大小是10000KB，已知某个虚拟地址为26000,我们就可以知道这个地址是  虚拟页面2的起始地址+6000  

后的一个地址。（虚拟页面0、虚拟页面1对应了前20000个地址），同理二进制数也这么看。

此处还要注意的一点是：1KB=2^10 B=1024B  而不是1KB=1000B。

 

 

第二步，知道了虚拟地址对应的虚拟页面是2后我们就可以查询页表，发现虚拟页面2对应的物理页面是110，

所以我们可以计算出所求虚拟地址对应的物理地址为：

110 0000 0000 0000（页面110的物理首地址）+100（偏移量）=110 0000 0000 0100

 

 

 

&补充题目（一道笔试题）

![img](https://img-blog.csdn.net/20180810232033708?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNzgwOTEw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

逻辑地址0对应的页为0 查询页表可知虚拟页0对应的物理页为2，

所以物理页的首地址是2×4×2^10=8192

再加上偏移量0 得出物理地址为8192+0=8192 所以选A。

 

注明：

  物理地址是从0开始标注的 ，

  假如一个页大小为16，

  那么第0页地址为0~15

  所以第1页首地址为16，也就是1×16=16

  所以第2页首地址为32，也就是2×16=32，

  以此类推。

​         